# Практика 5: Error-handling bottlenecks

**Мета:** Реалізація стратегій обробки помилок та підвищення відмовостійкості системи (Resilience Patterns).

## Реалізація вимог

Нижче наведено опис реалізації кожного з 8 пунктів завдання.

### 1. Ідемпотентність (Idempotency)
**Вимога:** Повторні запити з тим самим ключем не повинні створювати дублікатів.
**Реалізація:**
* Клієнт генерує хеш (SHA-256) від тіла запиту (`payload`) і надсилає його в заголовку `Idempotency-Key`.
* Бекенд зберігає пару `Key -> Response` у пам'яті (`idemStore`).
* Якщо ключ знайдено — сервер повертає збережену відповідь зі статусом `200 OK` (cached) замість створення нового запису.

### 2. Кореляція (Correlation ID)
**Вимога:** Наскрізний ідентифікатор запиту для логування.
**Реалізація:**
* Клієнт генерує UUID і надсилає його в заголовку `X-Request-Id`.
* Сервер зчитує цей ID, додає його до об'єкта `request` і включає в усі логи (`console.log`).
* Сервер повертає цей же ID у заголовку відповіді та в тілі помилки.

### 3. Ретраї з backoff (Retries)
**Вимога:** Повторення запитів при помилках 5xx та збоях мережі.
**Реалізація:**
* Використовується алгоритм **Exponential Backoff + Jitter**.
* Формула затримки: `delay = base * (2 ^ attempt) + random(0..200ms)`.
* Це запобігає одночасному навантаженню на сервер ("thundering herd problem") при відновленні роботи.

### 4. Rate-limit (Обмеження частоти)
**Вимога:** Обробка статусу 429 та заголовка Retry-After.
**Реалізація:**
* Сервер обмежує клієнта: максимум 5 запитів за 10 секунд.
* При перевищенні повертається статус `429 Too Many Requests` та заголовок `Retry-After: 3`.
* Клієнт автоматично зчитує час із заголовка, чекає вказану кількість секунд і повторює запит.

### 5. Таймаут клієнта (Client Timeout)
**Вимога:** Контрольоване переривання завислих запитів.
**Реалізація:**
* Використано Web API `AbortController`.
* Якщо запит триває довше 3000 мс (3 сек), клієнт викликає `controller.abort()`.
* Це генерує помилку `AbortError`, яку клієнт перехоплює і (за наявності спроб) відправляє в чергу ретраїв.

### 6. Єдиний формат помилки
**Вимога:** Стандартизована структура JSON для помилок.
**Реалізація:**
Всі помилки API повертаються у форматі:
```json
{
  "error": "too_many_requests",  // Тип помилки
  "code": "RATE_LIMIT",          // Машиночитабельний код
  "requestId": "a1b2-c3d4-..."   // ID для налагодження (з пункту 2)
}
```
### 7. Degraded Mode (Режим деградації)
**Вимога:** Візуальна реакція інтерфейсу на серію збоїв, щоб запобігти подальшому перевантаженню системи.
**Реалізація:**
* Використовується спрощений патерн **Circuit Breaker** на стороні фронтенду.
* Логіка:
    1. Клієнт підраховує кількість послідовних помилок (мережевих або 5xx).
    2. Якщо кількість помилок ≥ 2, активується "Degraded Mode".
    3. Користувачу відображається жовтий банер *"⚠️ Система перевантажена"*.
    4. Кнопка "Order (POST)" блокується (стає disabled) на 5 секунд (період охолодження/Cooldown).
    5. Після завершення таймера система автоматично повертається в нормальний стан.



### 8. Health Check
**Вимога:** Ендпоінт для моніторингу стану сервісу.
**Реалізація:**
* Реалізовано маршрут `GET /health`.
* Відповідь: `{ "status": "ok" }`.
* Додатково: сервер підтримує параметр `?delay=...` для емуляції повільної відповіді, що дозволяє протестувати налаштування таймаутів (пункт 5) та роботу AbortController на клієнті.

---

## Інструкція із запуску стенду

Прототип знаходиться в папці `practice5/`.

1. **Перейти в папку:**
   ```bash
   cd practice5
   ```

2. **Встановити залежності:**
    ```bash
   npm install
   ```

3. **Запустити сервер:**
    ```bash
   node server.js
   ```

4. **Відкрити інтерфейс:**
   - Відкрити файл `index.html` у браузері.
   - Або, якщо налаштовано static serve в `server.js`, перейдіть за адресою:
     ```bash
     http://localhost:8081
     ```
   
